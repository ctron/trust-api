use actix_web::{error, get, http::StatusCode, web, web::ServiceConfig, HttpResponse};

use serde::{Deserialize, Serialize};
use std::sync::Arc;
use thiserror::Error;
use utoipa::ToSchema;

use crate::{guac::Guac, package::PackageRef};

pub(crate) fn configure() -> impl FnOnce(&mut ServiceConfig) {
    |config: &mut ServiceConfig| {
        config.service(query_vulnerability);
    }
}

#[derive(serde::Deserialize)]
pub struct VulnerabilityQuery {
    cve: Option<String>,
}

#[utoipa::path(
    responses(
        (status = 200, description = "Vulnerability found", body = Vulnerability),
        (status = NOT_FOUND, description = "Vulnerability was not found"),
        (status = BAD_REQUEST, description = "Missing query argument")
    ),
    params(
        ("cve" = String, Query, description = "CVE id to query"),
    )
)]
#[get("/api/vulnerability")]
pub async fn query_vulnerability(
    query: web::Query<VulnerabilityQuery>,
    guac: web::Data<Arc<Guac>>,
) -> Result<HttpResponse, ApiError> {
    if let Some(cve) = &query.cve {
        Ok(
            HttpResponse::Ok().json(guac.get_vulnerability(cve).await.map_err(|_| {
                ApiError::NotFound {
                    cve: cve.to_string(),
                }
            })?),
        )
    } else {
        Err(ApiError::MissingQueryArgument)
    }
}

#[derive(ToSchema, Serialize, Deserialize)]
#[schema(example = json!(Vulnerability {
    cve: "CVE-1234".to_string(),
    summary: "It's broken".to_string(),
    advisory: "RHSA-4321".to_string(),
    packages: vec![
        PackageRef {
            purl: "pkg:maven/org.apache.quarkus/quarkus@1.2".to_string(),
            href: format!("/api/package?purl={}", &urlencoding::encode("pkg:maven/org.apache.quarkus/quarkus@1.2")),
            trusted: None,
        }
    ]
}))]
pub struct Vulnerability {
    pub cve: String,
    pub summary: String,
    pub advisory: String,
    pub packages: Vec<PackageRef>,
}

#[derive(Debug, Error, Serialize, Deserialize)]
pub enum ApiError {
    #[error("No query argument was specified")]
    MissingQueryArgument,
    #[error("CVE {cve} was not found")]
    NotFound { cve: String },
}

impl error::ResponseError for ApiError {
    fn error_response(&self) -> HttpResponse {
        HttpResponse::build(self.status_code()).json(serde_json::json!({
            "status": self.status_code().as_u16(),
            "error": self.to_string(),
        }))
    }

    fn status_code(&self) -> StatusCode {
        match self {
            ApiError::MissingQueryArgument => StatusCode::BAD_REQUEST,
            ApiError::NotFound { cve: _ } => StatusCode::NOT_FOUND,
        }
    }
}
